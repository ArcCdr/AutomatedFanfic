name: Publish Docker Image

on:
  # Trigger automatically AFTER "Python application CI" completes successfully on master
  workflow_run:
    workflows: ["Python application CI"]
    types:
      - completed
    branches:
      - master
  # Triggered explicitly by update-dependencies after successful CI
  workflow_call:
    inputs:
      commit_sha:
        description: 'The specific commit SHA to checkout and build (from update-dependencies)'
        required: true # Required when called
        type: string
    secrets: # Define secrets that can be passed by the caller
      DOCKERHUB_USER:
        required: true
      DOCKERHUB_PASSWORD:
        required: true
  # Allow manual triggering
  workflow_dispatch:
    inputs:
      ref:
        description: 'Branch, tag, or SHA to build (default: master)'
        required: false
        default: 'master'

env:
  IMAGE_REPO: mrtyton
  IMAGE_NAME: automated-ffdl

jobs:
  Push_Docker_Image:
    # Run if dispatched OR if workflow_run succeeded OR if called (implied)
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call' || github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    steps:
      # Determine the commit SHA based on trigger type
      - name: Determine Commit SHA
        id: get_sha
        run: |
          COMMIT_TO_CHECKOUT=""
          if [ "${{ github.event_name }}" == "workflow_call" ] && [ -n "${{ inputs.commit_sha }}" ]; then
            COMMIT_TO_CHECKOUT="${{ inputs.commit_sha }}"
            echo "Using commit SHA from workflow_call input: $COMMIT_TO_CHECKOUT"
          elif [ "${{ github.event_name }}" == "workflow_run" ]; then
            COMMIT_TO_CHECKOUT="${{ github.event.workflow_run.head_sha }}"
            echo "Using commit SHA from workflow_run event: $COMMIT_TO_CHECKOUT"
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ -n "${{ github.event.inputs.ref }}" ]; then
            # For workflow_dispatch, resolve the provided ref to a SHA
            COMMIT_TO_CHECKOUT=$(git ls-remote https://github.com/${{ github.repository }}.git ${{ github.event.inputs.ref }} | awk '{print $1}')
            echo "Using commit SHA from workflow_dispatch input ref (${{ github.event.inputs.ref }}): $COMMIT_TO_CHECKOUT"
            if [ -z "$COMMIT_TO_CHECKOUT" ]; then
              echo "::error::Could not resolve ref '${{ github.event.inputs.ref }}' to a commit SHA."
              exit 1
            fi
          else # Should only be workflow_dispatch without ref input now
            COMMIT_TO_CHECKOUT="${{ github.sha }}" # Default to current SHA for safety
            echo "Using default commit SHA for dispatch: $COMMIT_TO_CHECKOUT"
          fi
          echo "commit_sha=$COMMIT_TO_CHECKOUT" >> $GITHUB_OUTPUT

      # Checkout the specific commit, fetch parent for diff (needed for workflow_run check)
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.get_sha.outputs.commit_sha }}
          fetch-depth: 2 # Fetch commit and parent for diff

      # Check if the specific file was changed (only relevant for workflow_run)
      - name: Check for changes in latest.txt (for workflow_run)
        id: check_file
        # Only run this check if triggered by workflow_run
        if: github.event_name == 'workflow_run'
        run: |
          # Compare the checked-out commit (HEAD) with its parent (HEAD~1)
          if git diff --quiet HEAD~1 HEAD -- 'release-versions/latest.txt'; then
            echo "No changes detected in release-versions/latest.txt for commit ${{ steps.get_sha.outputs.commit_sha }}."
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected in release-versions/latest.txt for commit ${{ steps.get_sha.outputs.commit_sha }}."
            echo "changed=true" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true # Handle first commit case

      # --- Subsequent steps run if dispatched OR called OR if file changed on workflow_run ---
      - name: Set up QEMU
        # Run if dispatched OR called OR if workflow_run AND file changed
        if: github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call' || steps.check_file.outputs.changed == 'true'
        uses: docker/setup-qemu-action@v3

      - name: Setup Docker Buildx
        if: github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call' || steps.check_file.outputs.changed == 'true'
        uses: docker/setup-buildx-action@v3

      # Determine versions by reading files (always run if build proceeds)
      - name: Determine Versions and Tags from Files
        if: github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call' || steps.check_file.outputs.changed == 'true'
        id: set_versions
        run: |
          # Specific Version
          if [ -s "release-versions/latest.txt" ]; then
            SPECIFIC_VERSION=$(cat release-versions/latest.txt)
            echo "Read specific_version from file: $SPECIFIC_VERSION"
          else
            echo "::error::release-versions/latest.txt is missing or empty."
            exit 1
          fi
          # Calibre Version
          if [ -s "release-versions/calibre.txt" ]; then
             CALIBRE_VERSION=$(cat release-versions/calibre.txt)
             echo "Read calibre_version from file: $CALIBRE_VERSION"
          else
             echo "::error::release-versions/calibre.txt is missing or empty."
             exit 1
          fi
          # S6 Version
          if [ -s "release-versions/s6.txt" ]; then
             S6_VERSION=$(cat release-versions/s6.txt)
             echo "Read s6_version from file: $S6_VERSION"
          else
             echo "::error::release-versions/s6.txt is missing or empty."
             exit 1
          fi
          # Set environment variables for build args and tags
          echo "SPECIFIC_VERSION=$SPECIFIC_VERSION" >> $GITHUB_ENV
          echo "CALIBRE_VERSION=$CALIBRE_VERSION" >> $GITHUB_ENV
          echo "S6_VERSION=$S6_VERSION" >> $GITHUB_ENV
          # Put specific version tag first, then latest
          TAGS="${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:${SPECIFIC_VERSION},${{ env.IMAGE_REPO }}/${{ env.IMAGE_NAME }}:latest"
          echo "TAGS=$TAGS" >> $GITHUB_ENV
          echo "Docker Tags: $TAGS"

      - name: Print image tags and versions
        if: github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call' || steps.check_file.outputs.changed == 'true'
        run: |
          echo "Commit SHA: ${{ steps.get_sha.outputs.commit_sha }}"
          echo "Specific Version Tag: ${{ env.SPECIFIC_VERSION }}"
          echo "Calibre Version: ${{ env.CALIBRE_VERSION }}"
          echo "S6 Overlay Version: ${{ env.S6_VERSION }}"
          echo "Full Tags: ${{ env.TAGS }}"

      - name: Login to DockerHub
        if: github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call' || steps.check_file.outputs.changed == 'true'
        uses: docker/login-action@v3.0.0
        with:
          # Use secrets passed from the caller (workflow_call) or repository secrets (workflow_dispatch/workflow_run)
          username: ${{ secrets.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Build and push
        if: github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call' || steps.check_file.outputs.changed == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ env.TAGS }}
          build-args: |
            VERSION=${{ env.SPECIFIC_VERSION }}
            CALIBRE_RELEASE=${{ env.CALIBRE_VERSION }}
            S6_OVERLAY_VERSION=${{ env.S6_VERSION }}

      # Optional: Add a step to indicate skipping if the file didn't change on workflow_run
      - name: Skipped build on workflow_run
        if: github.event_name == 'workflow_run' && steps.check_file.outputs.changed == 'false'
        run: echo "Docker build skipped because release-versions/latest.txt was not changed in commit ${{ steps.get_sha.outputs.commit_sha }}."